<!DOCTYPE html>
<html lang="pl" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DnD Map Podgląd</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
        }
        .map-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
        }
        .map-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }
        .map-image {
            display: block;
            max-width: none;
            position: relative;
            user-select: none;
        }
        .fog-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="map-container" id="mapContainer">
        <div class="map-wrapper" id="mapWrapper">
            <img id="mapImage" class="map-image" th:src="@{/api/maps/{mapName}(mapName=${mapName})}" alt="Mapa" />
            <canvas id="fogLayer" class="fog-layer"></canvas>
            <canvas id="charactersLayer" class="fog-layer" style="z-index: 20;"></canvas>
        </div>
    </div>
    <script>
        const mapImage = document.getElementById('mapImage');
        const fogLayer = document.getElementById('fogLayer');
        let fogState = null;
        let mapInfo = null;
        let pollingInterval = null;
        let previewMapName = null;
        let animationFrame = null;
        let animationTime = 0;

        // Dodaj zmienne dla siatki
        let gridSize = null;
        let gridOffsetX = 0;
        let gridOffsetY = 0;

        // Zmienne dla kolorów mgły
        let fogColor = '#808080';
        let fogOpacity = 0.65;

        // Zmienne dla postaci
        const charactersLayer = document.getElementById('charactersLayer');
        const charactersCtx = charactersLayer.getContext('2d');
        let characters = { players: [], enemies: [] };
        let playerColor = '#00ff00';
        let enemyColor = '#ff0000';

        // Zmienne dla viewportu i zoom
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let rotation = 0;
        const mapContainer = document.getElementById('mapContainer');
        const mapWrapper = document.getElementById('mapWrapper');

        // Funkcja do aktualizacji transformacji
        function updateTransform() {
            if (!mapImage.complete) return;

            // Oblicz pozycję wrapper - chcemy żeby środek obrazu był w środku ekranu + pan
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            const imageWidth = mapImage.naturalWidth;
            const imageHeight = mapImage.naturalHeight;

            // Środek obrazu ma być w (containerWidth/2 + panX, containerHeight/2 + panY)
            // Więc lewy górny róg obrazu (który jest w pozycji 0,0 w wrapper) musi być w:
            const wrapperX = containerWidth / 2 + panX - (imageWidth * zoom) / 2;
            const wrapperY = containerHeight / 2 + panY - (imageHeight * zoom) / 2;

            // Zastosuj transformacje
            const transforms = [];
            transforms.push(`translate(${wrapperX}px, ${wrapperY}px)`);
            transforms.push(`scale(${zoom})`);

            if (rotation !== 0) {
                // Dla obrotu musimy zmienić transform-origin na środek obrazu
                mapWrapper.style.transformOrigin = `${imageWidth / 2}px ${imageHeight / 2}px`;
                transforms.push(`rotate(${rotation}deg)`);
            } else {
                mapWrapper.style.transformOrigin = '0 0';
            }

            mapWrapper.style.transform = transforms.join(' ');
            reportViewport();
        }

        // Funkcja do pobierania poleceń nawigacji z serwera
        function pollNavigationCommands() {
            setInterval(() => {
                fetch('/api/preview-map/navigation')
                    .then(res => res.json())
                    .then(command => {
                        if (command && command.action) {
                            handleNavigationCommand(command);
                        }
                    })
                    .catch(err => console.error('Error polling navigation:', err));
            }, 100);
        }

        // Obsługa poleceń nawigacji
        function handleNavigationCommand(command) {
            const step = 100;
            switch(command.action) {
                case 'pan':
                    if (command.direction === 'up') {
                        panY += step;
                    } else if (command.direction === 'down') {
                        panY -= step;
                    } else if (command.direction === 'left') {
                        panX += step;
                    } else if (command.direction === 'right') {
                        panX -= step;
                    }
                    updateTransform();
                    break;
                case 'zoom':
                    if (command.direction === 'in') {
                        zoom = Math.min(zoom * 1.2, 5);
                    } else if (command.direction === 'out') {
                        zoom = Math.max(zoom / 1.2, 0.1);
                    } else if (command.direction === 'reset') {
                        zoom = 1;
                        panX = 0;
                        panY = 0;
                    }
                    updateTransform();
                    break;
                case 'rotate':
                    if (command.rotation !== undefined) {
                        rotation = command.rotation;
                        updateTransform();
                    }
                    break;
                case 'rotatePreview':
                    // Obrót o podaną liczbę stopni (domyślnie 90)
                    const degrees = command.degrees || 90;
                    rotation = (rotation + degrees + 360) % 360;
                    updateTransform();
                    break;
                case 'center':
                    // Wycentruj mapę
                    panX = 0;
                    panY = 0;
                    updateTransform();
                    break;
            }
        }

        // Raportowanie viewport do serwera
        function reportViewport() {
            if (!mapImage.complete || !previewMapName) return;

            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            const imageWidth = mapImage.naturalWidth;
            const imageHeight = mapImage.naturalHeight;

            // Wrapper jest w pozycji tak, że lewy górny róg obrazu jest w:
            // wrapperX = containerWidth/2 + panX - (imageWidth * zoom) / 2
            // wrapperY = containerHeight/2 + panY - (imageHeight * zoom) / 2

            const wrapperX = containerWidth / 2 + panX - (imageWidth * zoom) / 2;
            const wrapperY = containerHeight / 2 + panY - (imageHeight * zoom) / 2;

            // Lewy górny róg widocznego obszaru ekranu to (0, 0)
            // Offset widocznego obszaru względem obrazu (w pikselach ekranu po zoom):
            const offsetX = 0 - wrapperX;
            const offsetY = 0 - wrapperY;

            // Przelicz na piksele oryginału obrazu (przed zoom):
            const visibleLeft = offsetX / zoom;
            const visibleTop = offsetY / zoom;
            const visibleWidth = containerWidth / zoom;
            const visibleHeight = containerHeight / zoom;

            console.log('Viewport Debug:', {
                panX, panY, zoom,
                containerWidth, containerHeight,
                imageWidth, imageHeight,
                wrapperX, wrapperY,
                offsetX, offsetY,
                visibleLeft, visibleTop, visibleWidth, visibleHeight
            });

            const viewport = {
                x: visibleLeft,
                y: visibleTop,
                width: visibleWidth,
                height: visibleHeight,
                zoom: zoom,
                rotation: rotation,
                mapWidth: imageWidth,
                mapHeight: imageHeight
            };

            fetch('/api/preview-map/viewport', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(viewport)
            }).catch(err => console.error('Error reporting viewport:', err));
        }

        // Raportuj viewport przy resize
        window.addEventListener('resize', () => {
            reportViewport();
        });

        function fetchPreviewMapName() {
            return fetch('/api/preview-map')
                .then(res => res.ok ? res.text() : null)
                .then(name => {
                    previewMapName = name;
                    return name;
                });
        }

        function fetchMapInfo() {
            if (!previewMapName) return;
            fetch(`/api/maps/${previewMapName}`)
                .then(res => res.json())
                .then(data => {
                    mapInfo = data;
                    mapImage.src = `/api/map-files/${mapInfo.filename}`;
                    mapImage.onload = () => {
                        // Wycentruj mapę i zgłoś viewport
                        updateTransform();
                        renderFog();
                    };
                });
        }

        function fetchFogState() {
            if (!previewMapName) return;
            fetch(`/api/fog/${previewMapName}`)
                .then(res => res.json())
                .then(data => {
                    fogState = data;
                    renderFog();
                });
        }

        function startPollingFog() {
            if (pollingInterval) clearInterval(pollingInterval);
            pollingInterval = setInterval(fetchFogState, 2000);
        }

        // Funkcje obsługi siatki
        function fetchGridConfig() {
            if (!previewMapName) return;
            fetch(`/api/grid/${previewMapName}`)
                .then(res => res.ok ? res.json() : null)
                .then(data => {
                    if (data && data.gridSize) {
                        gridSize = data.gridSize;
                        gridOffsetX = Math.round(data.offsetX || 0);
                        gridOffsetY = Math.round(data.offsetY || 0);
                        fetchCharacters(); // Pobierz postacie po załadowaniu siatki
                    }
                })
                .catch(() => { gridSize = null; });
        }

        // Funkcje obsługi postaci
        function fetchCharacters() {
            if (!previewMapName) return;

            // Pobierz postacie z localStorage (przez endpoint)
            fetch(`/api/characters/${previewMapName}`)
                .then(res => res.ok ? res.json() : null)
                .then(data => {
                    if (data) {
                        characters = data.characters || { players: [], enemies: [] };
                        playerColor = data.playerColor || '#00ff00';
                        enemyColor = data.enemyColor || '#ff0000';
                        drawCharacters();
                    }
                })
                .catch(err => console.error('Error fetching characters:', err));
        }

        function drawCharacters() {
            if (!mapImage.complete || !gridSize) return;

            // Ustaw rozmiar canvas
            charactersLayer.width = mapImage.naturalWidth;
            charactersLayer.height = mapImage.naturalHeight;

            // Wyczyść canvas
            charactersCtx.clearRect(0, 0, charactersLayer.width, charactersLayer.height);

            // Rysuj graczy (okręgi)
            charactersCtx.strokeStyle = playerColor;
            charactersCtx.fillStyle = playerColor + '40'; // 25% opacity
            charactersCtx.lineWidth = 3;

            characters.players.forEach(player => {
                const centerX = player.x + gridSize / 2;
                const centerY = player.y + gridSize / 2;
                const radius = gridSize / 2 - 5;

                charactersCtx.beginPath();
                charactersCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                charactersCtx.fill();
                charactersCtx.stroke();
            });

            // Rysuj wrogów (litery)
            charactersCtx.fillStyle = enemyColor;
            charactersCtx.font = `bold ${gridSize * 0.6}px Arial`;
            charactersCtx.textAlign = 'center';
            charactersCtx.textBaseline = 'middle';

            characters.enemies.forEach(enemy => {
                const centerX = enemy.x + gridSize / 2;
                const centerY = enemy.y + gridSize / 2;

                charactersCtx.fillText(enemy.letter, centerX, centerY);
            });
        }

        function startPollingCharacters() {
            setInterval(() => {
                fetchCharacters();
            }, 2000);
        }


        // Ulepszony szum dla bardziej realistycznej mgły
        function perlinNoise(x, y, seed = 0) {
            // Prosta implementacja szumu Perlina
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const fx = x - ix;
            const fy = y - iy;

            // Interpolacja dla płynności
            const u = fx * fx * (3 - 2 * fx);
            const v = fy * fy * (3 - 2 * fy);

            const a = Math.sin((ix + iy * 57 + seed) * 0.05) * Math.cos((ix * 37 + iy + seed) * 0.07);
            const b = Math.sin((ix + 1 + iy * 57 + seed) * 0.05) * Math.cos(((ix + 1) * 37 + iy + seed) * 0.07);
            const c = Math.sin((ix + (iy + 1) * 57 + seed) * 0.05) * Math.cos((ix * 37 + (iy + 1) + seed) * 0.07);
            const d = Math.sin((ix + 1 + (iy + 1) * 57 + seed) * 0.05) * Math.cos(((ix + 1) * 37 + (iy + 1) + seed) * 0.07);

            const k0 = a;
            const k1 = b - a;
            const k2 = c - a;
            const k3 = a - b - c + d;

            return (k0 + k1 * u + k2 * v + k3 * u * v + 1) * 0.5;
        }

        function drawFogBackground(ctx, width, height, time = 0) {
            // Walidacja wymiarów - muszą być większe niż 0
            if (!width || !height || width <= 0 || height <= 0) {
                console.warn('Invalid dimensions for fog background:', width, height);
                return;
            }

            const imageData = ctx.createImageData(width, height);

            // Szybszy, bardziej widoczny ruch mgły
            const step = 3; // Mniejszy krok dla gładszej mgły
            const windTime = time * 0.002; // Przyspieszony dryf - 2.5x szybszy

            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    // Skala dla różnych warstw
                    const scale1 = 0.003;
                    const scale2 = 0.006;
                    const scale3 = 0.012;

                    // Subtelne przesunięcia - mgła dryfuje powoli
                    const drift1X = Math.sin(windTime * 0.3) * 20;
                    const drift1Y = Math.cos(windTime * 0.2) * 15;
                    const drift2X = Math.sin(windTime * 0.5 + 100) * 30;
                    const drift2Y = Math.cos(windTime * 0.4 + 100) * 25;

                    // Trzy warstwy mgły o różnych skalach i prędkościach
                    const layer1 = perlinNoise((x + drift1X) * scale1, (y + drift1Y) * scale1, windTime * 10);
                    const layer2 = perlinNoise((x + drift2X) * scale2, (y + drift2Y) * scale2, windTime * 15 + 1000);
                    const layer3 = perlinNoise(x * scale3, y * scale3, windTime * 20 + 2000);

                    // Kombinacja warstw z różnymi wagami
                    const cloudDensity = layer1 * 0.5 + layer2 * 0.3 + layer3 * 0.2;

                    // Konwersja do odcieni szarości z większym kontrastem
                    const grayValue = Math.floor(50 + cloudDensity * 90);
                    const clampedGray = Math.max(40, Math.min(140, grayValue));

                    // Wypełnij blok
                    for (let dy = 0; dy < step && y + dy < height; dy++) {
                        for (let dx = 0; dx < step && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            imageData.data[idx] = clampedGray;
                            imageData.data[idx + 1] = clampedGray;
                            imageData.data[idx + 2] = clampedGray;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function renderFog() {
            if (!fogState || !mapImage.complete) return;

            // Ustaw wymiary canvas
            fogLayer.width = mapImage.naturalWidth;
            fogLayer.height = mapImage.naturalHeight;
            fogLayer.style.width = mapImage.width + 'px';
            fogLayer.style.height = mapImage.height + 'px';

            // Walidacja wymiarów
            if (!fogLayer.width || !fogLayer.height || fogLayer.width <= 0 || fogLayer.height <= 0) {
                console.warn('Invalid fog layer dimensions:', fogLayer.width, fogLayer.height);
                return;
            }

            const ctx = fogLayer.getContext('2d');
            ctx.clearRect(0, 0, fogLayer.width, fogLayer.height);
            drawFogBackground(ctx, fogLayer.width, fogLayer.height, animationTime);
            if (fogState && fogState.revealedAreas) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                fogState.revealedAreas.forEach(area => {
                    const looksLikeGridCell = gridSize && Math.abs(area.radius - gridSize / 2) < 0.01;
                    if (area.isGridCell || looksLikeGridCell) {
                        ctx.fillStyle = 'rgba(255,255,255,1)';
                        const cellX = area.x - area.radius;
                        const cellY = area.y - area.radius;
                        ctx.fillRect(cellX, cellY, area.radius * 2, area.radius * 2);
                    } else {
                        const gradient = ctx.createRadialGradient(area.x, area.y, area.radius * 0.5, area.x, area.y, area.radius);
                        gradient.addColorStop(0, 'rgba(255,255,255,1)');
                        gradient.addColorStop(1, 'rgba(255,255,255,0)');
                        ctx.beginPath();
                        ctx.arc(area.x, area.y, area.radius, 0, 2 * Math.PI);
                        ctx.closePath();
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    }
                });
                ctx.restore();
            }
        }

        function pollRefreshRequest() {
            setInterval(() => {
                fetch('/api/preview-map/refresh')
                    .then(res => res.json())
                    .then(refresh => {
                        if (refresh) {
                            window.location.reload();
                        }
                    });
            }, 2000);
        }

        function animateFog() {
            animationTime += 32; // ~60 FPS, szybsza animacja - 2x szybszy przyrost
            renderFog();
            animationFrame = requestAnimationFrame(animateFog);
        }

        function startFogAnimation() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            animateFog();
        }

        function stopFogAnimation() {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
        }

        window.onload = function() {
            fetchPreviewMapName().then(() => {
                fetchMapInfo();
                fetchGridConfig(); // Pobierz konfigurację siatki
                fetchFogState();
                startPollingFog();
                pollRefreshRequest();
                startFogAnimation();
                pollNavigationCommands(); // Nasłuchuj poleceń nawigacji
                startPollingCharacters(); // Nasłuchuj zmian w postaciach
                setTimeout(reportViewport, 1000); // Wyślij początkowy viewport
            });
        };
    </script>
</body>
</html>
